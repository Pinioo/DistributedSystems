//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.5
//
// <auto-generated>
//
// Generated from file `Office.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Office_h__
#define __Office_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 5
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Office
{

class Client;
class ClientPrx;
class OfficeRegistration;
class OfficeRegistrationPrx;

}

namespace Office
{

struct CaseInfo
{
    int clientId;
    bool paymentDone;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const bool&> ice_tuple() const
    {
        return std::tie(clientId, paymentDone);
    }
};

struct PassportCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string firstname;
    ::std::string lastname;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Office::CaseInfo&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(caseInfo, firstname, lastname);
    }
};

enum class Country : unsigned char
{
    USA,
    Germany,
    NorthKorea
};

struct VisaCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string passportId;
    ::Office::Country country;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Office::CaseInfo&, const ::std::string&, const ::Office::Country&> ice_tuple() const
    {
        return std::tie(caseInfo, passportId, country);
    }
};

using ExamResults = ::std::vector<bool>;

struct DriverLicenseCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string firstname;
    ::std::string lastname;
    ::Office::ExamResults examResults;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Office::CaseInfo&, const ::std::string&, const ::std::string&, const ::Office::ExamResults&> ice_tuple() const
    {
        return std::tie(caseInfo, firstname, lastname, examResults);
    }
};

enum class CaseStatusEnum : unsigned char
{
    REJECTED,
    APPROVED
};

struct CaseStatus
{
    int caseId;
    ::Office::CaseStatusEnum status;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::Office::CaseStatusEnum&> ice_tuple() const
    {
        return std::tie(caseId, status);
    }
};

struct CaseStartedInfo
{
    int caseId;
    bool serverHasProxy;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const bool&> ice_tuple() const
    {
        return std::tie(caseId, serverHasProxy);
    }
};

using CaseStatusCache = ::std::vector<CaseStatus>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Office
{

class Client : public virtual ::Ice::Object
{
public:

    using ProxyType = ClientPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void sendCaseStatus(CaseStatus caseStatus, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendCaseStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sendCachedCaseStatuses(CaseStatusCache caseStatusCache, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendCachedCaseStatuses(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OfficeRegistration : public virtual ::Ice::Object
{
public:

    using ProxyType = OfficeRegistrationPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual CaseStartedInfo startPassportCase(PassportCaseData passportCaseData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_startPassportCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CaseStartedInfo startVisaCase(VisaCaseData visaCaseData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_startVisaCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CaseStartedInfo startDriverLicenseCase(DriverLicenseCaseData driverLicenseCaseData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_startDriverLicenseCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void saveClient(int clientId, ::std::shared_ptr<ClientPrx> client, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_saveClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Office
{

class ClientPrx : public virtual ::Ice::Proxy<ClientPrx, ::Ice::ObjectPrx>
{
public:

    void sendCaseStatus(const CaseStatus& caseStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ClientPrx::_iceI_sendCaseStatus, caseStatus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sendCaseStatusAsync(const CaseStatus& caseStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ClientPrx::_iceI_sendCaseStatus, caseStatus, context);
    }

    ::std::function<void()>
    sendCaseStatusAsync(const CaseStatus& caseStatus,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Office::ClientPrx::_iceI_sendCaseStatus, caseStatus, context);
    }

    /// \cond INTERNAL
    void _iceI_sendCaseStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const CaseStatus&, const ::Ice::Context&);
    /// \endcond

    void sendCachedCaseStatuses(const CaseStatusCache& caseStatusCache, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ClientPrx::_iceI_sendCachedCaseStatuses, caseStatusCache, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sendCachedCaseStatusesAsync(const CaseStatusCache& caseStatusCache, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ClientPrx::_iceI_sendCachedCaseStatuses, caseStatusCache, context);
    }

    ::std::function<void()>
    sendCachedCaseStatusesAsync(const CaseStatusCache& caseStatusCache,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Office::ClientPrx::_iceI_sendCachedCaseStatuses, caseStatusCache, context);
    }

    /// \cond INTERNAL
    void _iceI_sendCachedCaseStatuses(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const CaseStatusCache&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ClientPrx() = default;
    friend ::std::shared_ptr<ClientPrx> IceInternal::createProxy<ClientPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OfficeRegistrationPrx : public virtual ::Ice::Proxy<OfficeRegistrationPrx, ::Ice::ObjectPrx>
{
public:

    CaseStartedInfo startPassportCase(const PassportCaseData& passportCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo>(true, this, &OfficeRegistrationPrx::_iceI_startPassportCase, passportCaseData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto startPassportCaseAsync(const PassportCaseData& passportCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Office::CaseStartedInfo>>().get_future())
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo, P>(false, this, &OfficeRegistrationPrx::_iceI_startPassportCase, passportCaseData, context);
    }

    ::std::function<void()>
    startPassportCaseAsync(const PassportCaseData& passportCaseData,
                           ::std::function<void(::Office::CaseStartedInfo)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Office::CaseStartedInfo>(std::move(response), std::move(ex), std::move(sent), this, &Office::OfficeRegistrationPrx::_iceI_startPassportCase, passportCaseData, context);
    }

    /// \cond INTERNAL
    void _iceI_startPassportCase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Office::CaseStartedInfo>>&, const PassportCaseData&, const ::Ice::Context&);
    /// \endcond

    CaseStartedInfo startVisaCase(const VisaCaseData& visaCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo>(true, this, &OfficeRegistrationPrx::_iceI_startVisaCase, visaCaseData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto startVisaCaseAsync(const VisaCaseData& visaCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Office::CaseStartedInfo>>().get_future())
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo, P>(false, this, &OfficeRegistrationPrx::_iceI_startVisaCase, visaCaseData, context);
    }

    ::std::function<void()>
    startVisaCaseAsync(const VisaCaseData& visaCaseData,
                       ::std::function<void(::Office::CaseStartedInfo)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Office::CaseStartedInfo>(std::move(response), std::move(ex), std::move(sent), this, &Office::OfficeRegistrationPrx::_iceI_startVisaCase, visaCaseData, context);
    }

    /// \cond INTERNAL
    void _iceI_startVisaCase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Office::CaseStartedInfo>>&, const VisaCaseData&, const ::Ice::Context&);
    /// \endcond

    CaseStartedInfo startDriverLicenseCase(const DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo>(true, this, &OfficeRegistrationPrx::_iceI_startDriverLicenseCase, driverLicenseCaseData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto startDriverLicenseCaseAsync(const DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Office::CaseStartedInfo>>().get_future())
    {
        return _makePromiseOutgoing<::Office::CaseStartedInfo, P>(false, this, &OfficeRegistrationPrx::_iceI_startDriverLicenseCase, driverLicenseCaseData, context);
    }

    ::std::function<void()>
    startDriverLicenseCaseAsync(const DriverLicenseCaseData& driverLicenseCaseData,
                                ::std::function<void(::Office::CaseStartedInfo)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Office::CaseStartedInfo>(std::move(response), std::move(ex), std::move(sent), this, &Office::OfficeRegistrationPrx::_iceI_startDriverLicenseCase, driverLicenseCaseData, context);
    }

    /// \cond INTERNAL
    void _iceI_startDriverLicenseCase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Office::CaseStartedInfo>>&, const DriverLicenseCaseData&, const ::Ice::Context&);
    /// \endcond

    void saveClient(int clientId, const ::std::shared_ptr<ClientPrx>& client, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OfficeRegistrationPrx::_iceI_saveClient, clientId, client, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto saveClientAsync(int clientId, const ::std::shared_ptr<ClientPrx>& client, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OfficeRegistrationPrx::_iceI_saveClient, clientId, client, context);
    }

    ::std::function<void()>
    saveClientAsync(int clientId, const ::std::shared_ptr<ClientPrx>& client,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Office::OfficeRegistrationPrx::_iceI_saveClient, clientId, client, context);
    }

    /// \cond INTERNAL
    void _iceI_saveClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::std::shared_ptr<ClientPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OfficeRegistrationPrx() = default;
    friend ::std::shared_ptr<OfficeRegistrationPrx> IceInternal::createProxy<OfficeRegistrationPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Office::CaseInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Office::CaseInfo, S>
{
    static void read(S* istr, ::Office::CaseInfo& v)
    {
        istr->readAll(v.clientId, v.paymentDone);
    }
};

template<>
struct StreamableTraits<::Office::PassportCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Office::PassportCaseData, S>
{
    static void read(S* istr, ::Office::PassportCaseData& v)
    {
        istr->readAll(v.caseInfo, v.firstname, v.lastname);
    }
};

template<>
struct StreamableTraits< ::Office::Country>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Office::VisaCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Office::VisaCaseData, S>
{
    static void read(S* istr, ::Office::VisaCaseData& v)
    {
        istr->readAll(v.caseInfo, v.passportId, v.country);
    }
};

template<>
struct StreamableTraits<::Office::DriverLicenseCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Office::DriverLicenseCaseData, S>
{
    static void read(S* istr, ::Office::DriverLicenseCaseData& v)
    {
        istr->readAll(v.caseInfo, v.firstname, v.lastname, v.examResults);
    }
};

template<>
struct StreamableTraits< ::Office::CaseStatusEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Office::CaseStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Office::CaseStatus, S>
{
    static void read(S* istr, ::Office::CaseStatus& v)
    {
        istr->readAll(v.caseId, v.status);
    }
};

template<>
struct StreamableTraits<::Office::CaseStartedInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Office::CaseStartedInfo, S>
{
    static void read(S* istr, ::Office::CaseStartedInfo& v)
    {
        istr->readAll(v.caseId, v.serverHasProxy);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Office
{

using ClientPtr = ::std::shared_ptr<Client>;
using ClientPrxPtr = ::std::shared_ptr<ClientPrx>;

using OfficeRegistrationPtr = ::std::shared_ptr<OfficeRegistration>;
using OfficeRegistrationPrxPtr = ::std::shared_ptr<OfficeRegistrationPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Office
{

class Client;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Client>&);
::IceProxy::Ice::Object* upCast(Client*);
/// \endcond

class OfficeRegistration;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OfficeRegistration>&);
::IceProxy::Ice::Object* upCast(OfficeRegistration*);
/// \endcond

}

}

namespace Office
{

class Client;
/// \cond INTERNAL
::Ice::Object* upCast(Client*);
/// \endcond
typedef ::IceInternal::Handle< Client> ClientPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Office::Client> ClientPrx;
typedef ClientPrx ClientPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ClientPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class OfficeRegistration;
/// \cond INTERNAL
::Ice::Object* upCast(OfficeRegistration*);
/// \endcond
typedef ::IceInternal::Handle< OfficeRegistration> OfficeRegistrationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Office::OfficeRegistration> OfficeRegistrationPrx;
typedef OfficeRegistrationPrx OfficeRegistrationPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OfficeRegistrationPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Office
{

struct CaseInfo
{
    ::Ice::Int clientId;
    bool paymentDone;

    bool operator==(const CaseInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(clientId != rhs_.clientId)
        {
            return false;
        }
        if(paymentDone != rhs_.paymentDone)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CaseInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(clientId < rhs_.clientId)
        {
            return true;
        }
        else if(rhs_.clientId < clientId)
        {
            return false;
        }
        if(paymentDone < rhs_.paymentDone)
        {
            return true;
        }
        else if(rhs_.paymentDone < paymentDone)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CaseInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const CaseInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const CaseInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const CaseInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct PassportCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string firstname;
    ::std::string lastname;

    bool operator==(const PassportCaseData& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(caseInfo != rhs_.caseInfo)
        {
            return false;
        }
        if(firstname != rhs_.firstname)
        {
            return false;
        }
        if(lastname != rhs_.lastname)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PassportCaseData& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(caseInfo < rhs_.caseInfo)
        {
            return true;
        }
        else if(rhs_.caseInfo < caseInfo)
        {
            return false;
        }
        if(firstname < rhs_.firstname)
        {
            return true;
        }
        else if(rhs_.firstname < firstname)
        {
            return false;
        }
        if(lastname < rhs_.lastname)
        {
            return true;
        }
        else if(rhs_.lastname < lastname)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PassportCaseData& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const PassportCaseData& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const PassportCaseData& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const PassportCaseData& rhs_) const
    {
        return !operator<(rhs_);
    }
};

enum Country
{
    USA,
    Germany,
    NorthKorea
};

struct VisaCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string passportId;
    ::Office::Country country;

    bool operator==(const VisaCaseData& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(caseInfo != rhs_.caseInfo)
        {
            return false;
        }
        if(passportId != rhs_.passportId)
        {
            return false;
        }
        if(country != rhs_.country)
        {
            return false;
        }
        return true;
    }

    bool operator<(const VisaCaseData& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(caseInfo < rhs_.caseInfo)
        {
            return true;
        }
        else if(rhs_.caseInfo < caseInfo)
        {
            return false;
        }
        if(passportId < rhs_.passportId)
        {
            return true;
        }
        else if(rhs_.passportId < passportId)
        {
            return false;
        }
        if(country < rhs_.country)
        {
            return true;
        }
        else if(rhs_.country < country)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const VisaCaseData& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const VisaCaseData& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const VisaCaseData& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const VisaCaseData& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<bool> ExamResults;

struct DriverLicenseCaseData
{
    ::Office::CaseInfo caseInfo;
    ::std::string firstname;
    ::std::string lastname;
    ::Office::ExamResults examResults;
};

enum CaseStatusEnum
{
    REJECTED,
    APPROVED
};

struct CaseStatus
{
    ::Ice::Int caseId;
    ::Office::CaseStatusEnum status;

    bool operator==(const CaseStatus& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(caseId != rhs_.caseId)
        {
            return false;
        }
        if(status != rhs_.status)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CaseStatus& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(caseId < rhs_.caseId)
        {
            return true;
        }
        else if(rhs_.caseId < caseId)
        {
            return false;
        }
        if(status < rhs_.status)
        {
            return true;
        }
        else if(rhs_.status < status)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CaseStatus& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const CaseStatus& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const CaseStatus& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const CaseStatus& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct CaseStartedInfo
{
    ::Ice::Int caseId;
    bool serverHasProxy;

    bool operator==(const CaseStartedInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(caseId != rhs_.caseId)
        {
            return false;
        }
        if(serverHasProxy != rhs_.serverHasProxy)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CaseStartedInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(caseId < rhs_.caseId)
        {
            return true;
        }
        else if(rhs_.caseId < caseId)
        {
            return false;
        }
        if(serverHasProxy < rhs_.serverHasProxy)
        {
            return true;
        }
        else if(rhs_.serverHasProxy < serverHasProxy)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CaseStartedInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const CaseStartedInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const CaseStartedInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const CaseStartedInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<CaseStatus> CaseStatusCache;

}

namespace Office
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::Client::begin_sendCaseStatus.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCaseStatus.
 */
class Callback_Client_sendCaseStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Client_sendCaseStatus_Base> Callback_Client_sendCaseStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCachedCaseStatuses.
 */
class Callback_Client_sendCachedCaseStatuses_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Client_sendCachedCaseStatuses_Base> Callback_Client_sendCachedCaseStatusesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startPassportCase.
 */
class Callback_OfficeRegistration_startPassportCase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OfficeRegistration_startPassportCase_Base> Callback_OfficeRegistration_startPassportCasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startVisaCase.
 */
class Callback_OfficeRegistration_startVisaCase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OfficeRegistration_startVisaCase_Base> Callback_OfficeRegistration_startVisaCasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startDriverLicenseCase.
 */
class Callback_OfficeRegistration_startDriverLicenseCase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OfficeRegistration_startDriverLicenseCase_Base> Callback_OfficeRegistration_startDriverLicenseCasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Office::OfficeRegistration::begin_saveClient.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_saveClient.
 */
class Callback_OfficeRegistration_saveClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OfficeRegistration_saveClient_Base> Callback_OfficeRegistration_saveClientPtr;

}

namespace IceProxy
{

namespace Office
{

class Client : public virtual ::Ice::Proxy<Client, ::IceProxy::Ice::Object>
{
public:

    void sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_sendCaseStatus(_iceI_begin_sendCaseStatus(caseStatus, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_sendCaseStatus(caseStatus, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCaseStatus(caseStatus, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCaseStatus(caseStatus, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Office::Callback_Client_sendCaseStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCaseStatus(caseStatus, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCaseStatus(const ::Office::CaseStatus& caseStatus, const ::Ice::Context& context, const ::Office::Callback_Client_sendCaseStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCaseStatus(caseStatus, context, cb, cookie);
    }

    void end_sendCaseStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_sendCaseStatus(const ::Office::CaseStatus&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_sendCachedCaseStatuses(_iceI_begin_sendCachedCaseStatuses(caseStatusCache, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_sendCachedCaseStatuses(caseStatusCache, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCachedCaseStatuses(caseStatusCache, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCachedCaseStatuses(caseStatusCache, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Office::Callback_Client_sendCachedCaseStatusesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCachedCaseStatuses(caseStatusCache, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache& caseStatusCache, const ::Ice::Context& context, const ::Office::Callback_Client_sendCachedCaseStatusesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendCachedCaseStatuses(caseStatusCache, context, cb, cookie);
    }

    void end_sendCachedCaseStatuses(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_sendCachedCaseStatuses(const ::Office::CaseStatusCache&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OfficeRegistration : public virtual ::Ice::Proxy<OfficeRegistration, ::IceProxy::Ice::Object>
{
public:

    ::Office::CaseStartedInfo startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_startPassportCase(_iceI_begin_startPassportCase(passportCaseData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_startPassportCase(passportCaseData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startPassportCase(passportCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startPassportCase(passportCaseData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Office::Callback_OfficeRegistration_startPassportCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startPassportCase(passportCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startPassportCase(const ::Office::PassportCaseData& passportCaseData, const ::Ice::Context& context, const ::Office::Callback_OfficeRegistration_startPassportCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startPassportCase(passportCaseData, context, cb, cookie);
    }

    ::Office::CaseStartedInfo end_startPassportCase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_startPassportCase(const ::Office::PassportCaseData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Office::CaseStartedInfo startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_startVisaCase(_iceI_begin_startVisaCase(visaCaseData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_startVisaCase(visaCaseData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startVisaCase(visaCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startVisaCase(visaCaseData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Office::Callback_OfficeRegistration_startVisaCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startVisaCase(visaCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startVisaCase(const ::Office::VisaCaseData& visaCaseData, const ::Ice::Context& context, const ::Office::Callback_OfficeRegistration_startVisaCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startVisaCase(visaCaseData, context, cb, cookie);
    }

    ::Office::CaseStartedInfo end_startVisaCase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_startVisaCase(const ::Office::VisaCaseData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Office::CaseStartedInfo startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_startDriverLicenseCase(_iceI_begin_startDriverLicenseCase(driverLicenseCaseData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_startDriverLicenseCase(driverLicenseCaseData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startDriverLicenseCase(driverLicenseCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startDriverLicenseCase(driverLicenseCaseData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Office::Callback_OfficeRegistration_startDriverLicenseCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startDriverLicenseCase(driverLicenseCaseData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Context& context, const ::Office::Callback_OfficeRegistration_startDriverLicenseCasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startDriverLicenseCase(driverLicenseCaseData, context, cb, cookie);
    }

    ::Office::CaseStartedInfo end_startDriverLicenseCase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_startDriverLicenseCase(const ::Office::DriverLicenseCaseData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_saveClient(_iceI_begin_saveClient(clientId, client, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_saveClient(clientId, client, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_saveClient(clientId, client, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_saveClient(clientId, client, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Office::Callback_OfficeRegistration_saveClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_saveClient(clientId, client, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_saveClient(::Ice::Int clientId, const ::Office::ClientPrx& client, const ::Ice::Context& context, const ::Office::Callback_OfficeRegistration_saveClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_saveClient(clientId, client, context, cb, cookie);
    }

    void end_saveClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_saveClient(::Ice::Int, const ::Office::ClientPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Office
{

class Client : public virtual ::Ice::Object
{
public:

    typedef ClientPrx ProxyType;
    typedef ClientPtr PointerType;

    virtual ~Client();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void sendCaseStatus(const CaseStatus& caseStatus, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_sendCaseStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sendCachedCaseStatuses(const CaseStatusCache& caseStatusCache, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_sendCachedCaseStatuses(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Client& lhs, const Client& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Client& lhs, const Client& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OfficeRegistration : public virtual ::Ice::Object
{
public:

    typedef OfficeRegistrationPrx ProxyType;
    typedef OfficeRegistrationPtr PointerType;

    virtual ~OfficeRegistration();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual CaseStartedInfo startPassportCase(const PassportCaseData& passportCaseData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_startPassportCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CaseStartedInfo startVisaCase(const VisaCaseData& visaCaseData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_startVisaCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CaseStartedInfo startDriverLicenseCase(const DriverLicenseCaseData& driverLicenseCaseData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_startDriverLicenseCase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void saveClient(::Ice::Int clientId, const ClientPrx& client, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_saveClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OfficeRegistration& lhs, const OfficeRegistration& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OfficeRegistration& lhs, const OfficeRegistration& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Office::CaseInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Office::CaseInfo, S>
{
    static void write(S* ostr, const ::Office::CaseInfo& v)
    {
        ostr->write(v.clientId);
        ostr->write(v.paymentDone);
    }
};

template<typename S>
struct StreamReader< ::Office::CaseInfo, S>
{
    static void read(S* istr, ::Office::CaseInfo& v)
    {
        istr->read(v.clientId);
        istr->read(v.paymentDone);
    }
};

template<>
struct StreamableTraits< ::Office::PassportCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Office::PassportCaseData, S>
{
    static void write(S* ostr, const ::Office::PassportCaseData& v)
    {
        ostr->write(v.caseInfo);
        ostr->write(v.firstname);
        ostr->write(v.lastname);
    }
};

template<typename S>
struct StreamReader< ::Office::PassportCaseData, S>
{
    static void read(S* istr, ::Office::PassportCaseData& v)
    {
        istr->read(v.caseInfo);
        istr->read(v.firstname);
        istr->read(v.lastname);
    }
};

template<>
struct StreamableTraits< ::Office::Country>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Office::VisaCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Office::VisaCaseData, S>
{
    static void write(S* ostr, const ::Office::VisaCaseData& v)
    {
        ostr->write(v.caseInfo);
        ostr->write(v.passportId);
        ostr->write(v.country);
    }
};

template<typename S>
struct StreamReader< ::Office::VisaCaseData, S>
{
    static void read(S* istr, ::Office::VisaCaseData& v)
    {
        istr->read(v.caseInfo);
        istr->read(v.passportId);
        istr->read(v.country);
    }
};

template<>
struct StreamableTraits< ::Office::DriverLicenseCaseData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Office::DriverLicenseCaseData, S>
{
    static void write(S* ostr, const ::Office::DriverLicenseCaseData& v)
    {
        ostr->write(v.caseInfo);
        ostr->write(v.firstname);
        ostr->write(v.lastname);
        ostr->write(v.examResults);
    }
};

template<typename S>
struct StreamReader< ::Office::DriverLicenseCaseData, S>
{
    static void read(S* istr, ::Office::DriverLicenseCaseData& v)
    {
        istr->read(v.caseInfo);
        istr->read(v.firstname);
        istr->read(v.lastname);
        istr->read(v.examResults);
    }
};

template<>
struct StreamableTraits< ::Office::CaseStatusEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Office::CaseStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Office::CaseStatus, S>
{
    static void write(S* ostr, const ::Office::CaseStatus& v)
    {
        ostr->write(v.caseId);
        ostr->write(v.status);
    }
};

template<typename S>
struct StreamReader< ::Office::CaseStatus, S>
{
    static void read(S* istr, ::Office::CaseStatus& v)
    {
        istr->read(v.caseId);
        istr->read(v.status);
    }
};

template<>
struct StreamableTraits< ::Office::CaseStartedInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Office::CaseStartedInfo, S>
{
    static void write(S* ostr, const ::Office::CaseStartedInfo& v)
    {
        ostr->write(v.caseId);
        ostr->write(v.serverHasProxy);
    }
};

template<typename S>
struct StreamReader< ::Office::CaseStartedInfo, S>
{
    static void read(S* istr, ::Office::CaseStartedInfo& v)
    {
        istr->read(v.caseId);
        istr->read(v.serverHasProxy);
    }
};

}
/// \endcond

namespace Office
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::Client::begin_sendCaseStatus.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCaseStatus.
 */
template<class T>
class CallbackNC_Client_sendCaseStatus : public Callback_Client_sendCaseStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Client_sendCaseStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCaseStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCaseStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCaseStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCaseStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::Client::begin_sendCaseStatus.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCaseStatus.
 */
template<class T, typename CT>
class Callback_Client_sendCaseStatus : public Callback_Client_sendCaseStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Client_sendCaseStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T, typename CT> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCaseStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T, typename CT> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCaseStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T, typename CT> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCaseStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCaseStatus.
 */
template<class T, typename CT> Callback_Client_sendCaseStatusPtr
newCallback_Client_sendCaseStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCaseStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCachedCaseStatuses.
 */
template<class T>
class CallbackNC_Client_sendCachedCaseStatuses : public Callback_Client_sendCachedCaseStatuses_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Client_sendCachedCaseStatuses(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCachedCaseStatuses<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCachedCaseStatuses<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCachedCaseStatuses<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Client_sendCachedCaseStatuses<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 * Create a wrapper instance by calling ::Office::newCallback_Client_sendCachedCaseStatuses.
 */
template<class T, typename CT>
class Callback_Client_sendCachedCaseStatuses : public Callback_Client_sendCachedCaseStatuses_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Client_sendCachedCaseStatuses(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T, typename CT> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCachedCaseStatuses<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T, typename CT> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCachedCaseStatuses<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T, typename CT> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCachedCaseStatuses<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::Client::begin_sendCachedCaseStatuses.
 */
template<class T, typename CT> Callback_Client_sendCachedCaseStatusesPtr
newCallback_Client_sendCachedCaseStatuses(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Client_sendCachedCaseStatuses<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startPassportCase.
 */
template<class T>
class CallbackNC_OfficeRegistration_startPassportCase : public Callback_OfficeRegistration_startPassportCase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CaseStartedInfo&);

    CallbackNC_OfficeRegistration_startPassportCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startPassportCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 */
template<class T> Callback_OfficeRegistration_startPassportCasePtr
newCallback_OfficeRegistration_startPassportCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startPassportCase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 */
template<class T> Callback_OfficeRegistration_startPassportCasePtr
newCallback_OfficeRegistration_startPassportCase(T* instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startPassportCase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startPassportCase.
 */
template<class T, typename CT>
class Callback_OfficeRegistration_startPassportCase : public Callback_OfficeRegistration_startPassportCase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CaseStartedInfo&, const CT&);

    Callback_OfficeRegistration_startPassportCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startPassportCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startPassportCasePtr
newCallback_OfficeRegistration_startPassportCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startPassportCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startPassportCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startPassportCasePtr
newCallback_OfficeRegistration_startPassportCase(T* instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startPassportCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startVisaCase.
 */
template<class T>
class CallbackNC_OfficeRegistration_startVisaCase : public Callback_OfficeRegistration_startVisaCase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CaseStartedInfo&);

    CallbackNC_OfficeRegistration_startVisaCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startVisaCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 */
template<class T> Callback_OfficeRegistration_startVisaCasePtr
newCallback_OfficeRegistration_startVisaCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startVisaCase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 */
template<class T> Callback_OfficeRegistration_startVisaCasePtr
newCallback_OfficeRegistration_startVisaCase(T* instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startVisaCase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startVisaCase.
 */
template<class T, typename CT>
class Callback_OfficeRegistration_startVisaCase : public Callback_OfficeRegistration_startVisaCase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CaseStartedInfo&, const CT&);

    Callback_OfficeRegistration_startVisaCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startVisaCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startVisaCasePtr
newCallback_OfficeRegistration_startVisaCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startVisaCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startVisaCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startVisaCasePtr
newCallback_OfficeRegistration_startVisaCase(T* instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startVisaCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startDriverLicenseCase.
 */
template<class T>
class CallbackNC_OfficeRegistration_startDriverLicenseCase : public Callback_OfficeRegistration_startDriverLicenseCase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CaseStartedInfo&);

    CallbackNC_OfficeRegistration_startDriverLicenseCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startDriverLicenseCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 */
template<class T> Callback_OfficeRegistration_startDriverLicenseCasePtr
newCallback_OfficeRegistration_startDriverLicenseCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startDriverLicenseCase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 */
template<class T> Callback_OfficeRegistration_startDriverLicenseCasePtr
newCallback_OfficeRegistration_startDriverLicenseCase(T* instance, void (T::*cb)(const CaseStartedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_startDriverLicenseCase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_startDriverLicenseCase.
 */
template<class T, typename CT>
class Callback_OfficeRegistration_startDriverLicenseCase : public Callback_OfficeRegistration_startDriverLicenseCase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CaseStartedInfo&, const CT&);

    Callback_OfficeRegistration_startDriverLicenseCase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OfficeRegistrationPrx proxy = OfficeRegistrationPrx::uncheckedCast(result->getProxy());
        CaseStartedInfo ret;
        try
        {
            ret = proxy->end_startDriverLicenseCase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startDriverLicenseCasePtr
newCallback_OfficeRegistration_startDriverLicenseCase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startDriverLicenseCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_startDriverLicenseCase.
 */
template<class T, typename CT> Callback_OfficeRegistration_startDriverLicenseCasePtr
newCallback_OfficeRegistration_startDriverLicenseCase(T* instance, void (T::*cb)(const CaseStartedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_startDriverLicenseCase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Office::OfficeRegistration::begin_saveClient.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_saveClient.
 */
template<class T>
class CallbackNC_OfficeRegistration_saveClient : public Callback_OfficeRegistration_saveClient_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OfficeRegistration_saveClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_saveClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_saveClient<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_saveClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OfficeRegistration_saveClient<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Office::OfficeRegistration::begin_saveClient.
 * Create a wrapper instance by calling ::Office::newCallback_OfficeRegistration_saveClient.
 */
template<class T, typename CT>
class Callback_OfficeRegistration_saveClient : public Callback_OfficeRegistration_saveClient_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OfficeRegistration_saveClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T, typename CT> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_saveClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T, typename CT> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_saveClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T, typename CT> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_saveClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Office::OfficeRegistration::begin_saveClient.
 */
template<class T, typename CT> Callback_OfficeRegistration_saveClientPtr
newCallback_OfficeRegistration_saveClient(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OfficeRegistration_saveClient<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
